?RCS: $Id: d_gconvert.U,v 3.0.1.3 1997/02/28 15:33:38 ram Exp $
?RCS:
?RCS: Copyright (c) 1991-1993, Raphael Manfredi
?RCS: 
?RCS: You may redistribute only under the terms of the Artistic Licence,
?RCS: as specified in the README file that comes with the distribution.
?RCS: You may reuse parts of this distribution only within the terms of
?RCS: that same Artistic Licence; a copy of which may be found at the root
?RCS: of the source tree for dist 3.0.
?RCS:
?RCS: Original Author: Andy Dougherty <doughera@lafcol.lafayette.edu>
?RCS:
?RCS: $Log: d_gconvert.U,v $
?RCS: Revision 3.0.1.3	1997/02/28  15:33:38  ram
?RCS: patch61: integrated new unit from perl5
?RCS:
?RCS: Revision 3.0.1.2	1995/07/25  13:55:59  ram
?RCS: patch56: improved comments about the Gconvert macro (ADO)
?RCS: patch56: force compile-link test since it may exist but be unusable (ADO)
?RCS:
?RCS: Revision 3.0.1.1	1994/10/29  16:12:51  ram
?RCS: patch36: created by ADO
?RCS:
?MAKE:d_Gconvert: Compile cat Inlibc rm _o i_stdlib d_qgcvt \
	uselongdouble d_longdbl d_PRIgldbl sPRIgldbl
?MAKE:	-pick add $@ %<
?S:d_Gconvert:
?S:	This variable holds what Gconvert is defined as to convert
?S:	floating point numbers into strings. It could be 'gconvert'
?S:	or a more complex macro emulating gconvert with gcvt() or sprintf.
?S:	Possible values are:
?S:		d_Gconvert='gconvert((x),(n),(t),(b))'
?S:		d_Gconvert='gcvt((x),(n),(b))'
?S:		d_Gconvert='sprintf((b),"%.*g",(n),(x))'
?S:.
?C:Gconvert:
?C:	This preprocessor macro is defined to convert a floating point
?C:	number to a string without a trailing decimal point.  This
?C:	emulates the behavior of sprintf("%g"), but is sometimes much more
?C:	efficient.  If gconvert() is not available, but gcvt() drops the
?C:	trailing decimal point, then gcvt() is used.  If all else fails,
?C:	a macro using sprintf("%g") is used. Arguments for the Gconvert
?C:	macro are: value, number of digits, whether trailing zeros should
?C:	be retained, and the output buffer.
?C:	Possible values are:
?C:		d_Gconvert='gconvert((x),(n),(t),(b))'
?C:		d_Gconvert='gcvt((x),(n),(b))'
?C:		d_Gconvert='sprintf((b),"%.*g",(n),(x))'
?C:	The last two assume trailing zeros should not be kept.
?C:.
?H:#define Gconvert(x,n,t,b) $d_Gconvert
?H:.
?T: xxx_list xxx_convert
?F:!try
?X: 
: Check how to convert floats to strings.
echo " "
echo "Checking for an efficient way to convert floats to strings."
echo " " > try.c
case "$uselongdouble" in
"$define") echo "#define USE_LONG_DOUBLE" >>try.c ;;
esac
case "$d_longdbl" in
"$define") echo "#define HAS_LONG_DOUBLE" >>try.c ;;
esac
case "$d_PRIgldbl" in
"$define") echo "#define HAS_PRIgldbl"    >>try.c ;;
esac
$cat >>try.c <<EOP
#ifdef TRY_gconvert
#define Gconvert(x,n,t,b) gconvert((x),(n),(t),(b))
char *myname = "gconvert";
#endif
#ifdef TRY_gcvt
#define Gconvert(x,n,t,b) gcvt((x),(n),(b))
char *myname = "gcvt";
#endif
#ifdef TRY_qgcvt
#define Gconvert(x,n,t,b) qgcvt((x),(n),(b))
char *myname = "qgcvt";
#define DOUBLETYPE long double
#endif
#ifdef TRY_sprintf
#if defined(USE_LONG_DOUBLE) && defined(HAS_LONG_DOUBLE) && defined(HAS_PRIgldbl)
#define Gconvert(x,n,t,b) sprintf((b),"%.*"$sPRIgldbl,(n),(x))
#else
#define Gconvert(x,n,t,b) sprintf((b),"%.*g",(n),(x))
#endif
char *myname = "sprintf";
#endif

#ifndef DOUBLETYPE
#if defined(USE_LONG_DOUBLE) && defined(HAS_LONG_DOUBLE)
#define DOUBLETYPE long double
#else
#define DOUBLETYPE double
#endif
#endif

#include <stdio.h>

#define I_STDLIB $i_stdlib
#ifdef I_STDLIB
#include <stdlib.h>
#endif

int
checkit(expect, got)
char *expect;
char *got;
{
    if (strcmp(expect, got)) {
		printf("%s oddity:  Expected %s, got %s\n",
			myname, expect, got);
		exit(1);
	}
}

int main()
{ 
	char buf[64]; 
	buf[63] = '\0';

	/* This must be 1st test on (which?) platform */
	/* Alan Burlison <AlanBurlsin@unn.unisys.com> */
	Gconvert((DOUBLETYPE)0.1, 8, 0, buf);
	checkit("0.1", buf);

	Gconvert((DOUBLETYPE)1.0, 8, 0, buf); 
	checkit("1", buf);

	Gconvert((DOUBLETYPE)1.1, 8, 0, buf); 
	checkit("1.1", buf);

	Gconvert((DOUBLETYPE)1.01, 8, 0, buf); 
	checkit("1.01", buf);

	Gconvert((DOUBLETYPE)1.001, 8, 0, buf); 
	checkit("1.001", buf);

	Gconvert((DOUBLETYPE)1.0001, 8, 0, buf); 
	checkit("1.0001", buf);

	Gconvert((DOUBLETYPE)1.00001, 8, 0, buf); 
	checkit("1.00001", buf);

	Gconvert((DOUBLETYPE)1.000001, 8, 0, buf); 
	checkit("1.000001", buf);

	Gconvert((DOUBLETYPE)0.0, 8, 0, buf); 
	checkit("0", buf);

	Gconvert((DOUBLETYPE)-1.0, 8, 0, buf); 
	checkit("-1", buf);

	/* Some Linux gcvt's give 1.e+5 here. */
	Gconvert((DOUBLETYPE)100000.0, 8, 0, buf); 
	checkit("100000", buf);
	
	/* Some Linux gcvt's give -1.e+5 here. */
	Gconvert((DOUBLETYPE)-100000.0, 8, 0, buf); 
	checkit("-100000", buf);

	Gconvert((DOUBLETYPE)123.456, 8, 0, buf); 
	checkit("123.456", buf);

	exit(0);
}
EOP
?X: List of order in which to search for functions.
?X: Usual order of efficiency is gconvert gcvt sprintf
?X: If a hint file sets a d_Gconvert="gconvert" or "gcvt" or "sprintf",
?X: then that is taken as a hint for which function to try first.
?X: (e.g. that function may be in a problematic /usr/ucblib library, and
?X: the user may or may not choose to use -lucb stuff.)
?X: Any other hint file (or previous config.sh) setting is left intact.
case "$d_Gconvert" in
gconvert*) xxx_list='gconvert gcvt sprintf' ;;
gcvt*) xxx_list='gcvt gconvert sprintf' ;;
sprintf*) xxx_list='sprintf gconvert gcvt' ;;
*) xxx_list='gconvert gcvt sprintf' ;;
esac

case "$d_longdbl$uselongdouble$d_PRIgldbl" in
"$define$define$define")
    # for long doubles prefer first qgcvt, then sprintf
    xxx_list="`echo $xxx_list|sed s/sprintf//`" 
    xxx_list="sprintf $xxx_list"
    case "$d_qgcvt" in
    "$define") xxx_list="qgcvt $xxx_list" ;;
    esac
    ;;
esac

for xxx_convert in $xxx_list; do
	echo "Trying $xxx_convert..."
	$rm -f try try$_o
	set try -DTRY_$xxx_convert
	if eval $compile; then
		echo "$xxx_convert() found." >&4
		if ./try; then
			echo "I'll use $xxx_convert to convert floats into a string." >&4
			break;
		else
			echo "...But $xxx_convert didn't work as I expected."
		fi
	else
		echo "$xxx_convert NOT found." >&4
	fi
done
	
case "$xxx_convert" in
gconvert) d_Gconvert='gconvert((x),(n),(t),(b))' ;;
gcvt) d_Gconvert='gcvt((x),(n),(b))' ;;
qgcvt) d_Gconvert='qgcvt((x),(n),(b))' ;;
*) case "$uselongdouble$d_longdbl$d_PRIgldbl" in
   "$define$define$define")
      d_Gconvert="sprintf((b),\"%.*\"$sPRIgldbl,(n),(x))" ;;
   *) d_Gconvert='sprintf((b),"%.*g",(n),(x))' ;;
   esac
   ;;  
esac

